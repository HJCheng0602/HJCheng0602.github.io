---
title: ä¸ºSLAM3Rè¡¥å……å®æ—¶å¤„ç†å‡½æ•°æ–¹æ³•
publishDate: 2025-08-12 15:57:00
description: 'åŸæœ¬çš„SLAM3Rçš„recon.pyçš„å¤„ç†é¡ºåºæ˜¯ä¸€ä¸ªofflineçš„é€»è¾‘ï¼Œå°†å…¶æ·»åŠ äº†onlineå¤„ç†çš„recon_online.py'
tags: 
- 3Dreconstruction
- coding
draft: false 
language: 'ä¸­æ–‡'
heroImage: { src: 'image.png' , color: '#B4C6DA' }
---
import { Spoiler } from 'astro-pure/user'

åœ¨ä¸Šä¸ªå‘¨é˜…è¯»**SLAM3R**è®ºæ–‡ç»“æŸåï¼Œå­¦é•¿è®©æˆ‘å»çœ‹ä¸€ä¸‹å®ƒçš„[æºä»£ç ](https://github.com/PKU-VCL-3DV/SLAM3R)ï¼Œè¯»å®Œä»£ç ä¹‹åï¼Œå‘ç°è™½ç„¶è®ºæ–‡é‡Œè®²è¿°çš„æ˜¯â€œå¯ä»¥å®æ—¶é‡å»ºâ€ï¼Œä½†æ˜¯å®é™…ä¸Šåœ¨`recon.py`æ–‡ä»¶ä¸­çš„`scene_recon_pipeline`å‡½æ•°ä¸­ï¼Œä»£ç é‡‡å–äº†å…ˆå¯¹æ‰€æœ‰`input_views`è¿›è¡Œè¾“å…¥åˆ°`i2p_model`å¾—åˆ°`res_feats`ï¼Œç„¶åå†å°†æ‰€æœ‰å›¾ç‰‡çš„tokenè¾“å…¥åˆ°l2wç½‘ç»œä¸­è¿›è¡Œé‡å»ºçš„å¤§è‡´é€»è¾‘ã€‚

æ˜¾ç„¶ï¼Œè¿™æ ·çš„å¤„ç†æ–¹æ³•ä¸æ˜¯è®ºæ–‡é‡Œæ‰€æå‡ºçš„**online**å¤„ç†æ–¹æ³•ï¼Œå› æ­¤ï¼Œåœ¨è¿‡å»çš„ä¸€ä¸ªå‘¨é‡Œï¼Œæœ¬äººä¸€è¾¹ç»ƒç€ç§‘ä¸‰<Spoiler>æ˜¾ç„¶ä»Šå¤©ä¸ŠåˆåˆšæŒ‚æ‰ï¼Œè¯¥æ­»çš„ç›´çº¿è¡Œé©¶ğŸ˜¡</Spoiler>ï¼ŒåŒæ—¶æŠ½å‡ºäº†ä¸€ç‚¹ç‚¹æ—¶é—´å®Œæˆäº†`recon_online.py`,ä¸€ä¸ªæŠŠåŸæœ¬çš„`scene_recon_pipeline`æ”¹æˆ`online`å¤„ç†çš„æ”¹åŠ¨ã€‚

## åŸå‡½æ•°çš„å¤„ç†é€»è¾‘
é˜…è¯»åŸå‡½æ•°çš„ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶åˆ†ä¸ºä»¥ä¸‹å‡ æ®µï¼š

### é¢„å¤„ç†&å¾—åˆ°æ‰€æœ‰viewçš„token
```python
# Pre-save the RGB images along with their corresponding masks 
# in preparation for visualization at last.
rgb_imgs = []
for i in range(len(data_views)):
    if data_views[i]['img'].shape[0] == 1:
        data_views[i]['img'] = data_views[i]['img'][0]        
    rgb_imgs.append(transform_img(dict(img=data_views[i]['img'][None]))[...,::-1])
if 'valid_mask' not in data_views[0]:
    valid_masks = None
else:
    valid_masks = [view['valid_mask'] for view in data_views]   

#preprocess data for extracting their img tokens with encoder
for view in data_views:
    view['img'] = torch.tensor(view['img'][None])
    view['true_shape'] = torch.tensor(view['true_shape'][None])
    for key in ['valid_mask', 'pts3d_cam', 'pts3d']:
        if key in view:
            del view[key]
    to_device(view, device=args.device)
# pre-extract img tokens by encoder, which can be reused 
# in the following inference by both i2p and l2w models
res_shapes, res_feats, res_poses = get_img_tokens(data_views, i2p_model)    # 300+fps
print('finish pre-extracting img tokens')
```
è¿™é‡Œé‡ç‚¹å°±æ˜¯æœ€åçš„`res_shapes, res_feats, res_poses = get_img_tokens(data_views, i2p_model)`ï¼Œé‡‡ç”¨`i2p_model`çš„`_encode_multiview`æ–¹æ³•æ‰¹æ¬¡åŒ–åœ°(*batchify*)å¯¹`data_views`è¿›è¡Œå¤„ç†ï¼Œä»è€Œå¾—åˆ°æ‰€æœ‰çš„viewçš„`token`ã€‚

### å¯¹æ‰€æœ‰viewè¿›è¡Œæ¨ç†å¾—åˆ°æœ€åˆé€‚çš„key_frame_stride

è¿™é‡Œçš„æ ¸å¿ƒä»£ç å°±æ˜¯ï¼š
```python
# decide the stride of sampling keyframes, as well as other related parameters
if args.keyframe_stride == -1:
    kf_stride = adapt_keyframe_stride(input_views, i2p_model, 
                                        win_r = 3,
                                        adapt_min=args.keyframe_adapt_min,
                                        adapt_max=args.keyframe_adapt_max,
                                        adapt_stride=args.keyframe_adapt_stride)
else:
    kf_stride = args.keyframe_stride
```
å…¶ä¸­ï¼Œ`adapt_keyframe_stride`å‡½æ•°æ˜¯ä¸€ä¸ªå…¸å‹çš„**offline**å¤„ç†å‡½æ•°ï¼Œå®ƒçš„åŠŸèƒ½æ˜¯åœ¨æ‰€æœ‰çš„input_viewä¸­éå†å¯èƒ½çš„`kf_stride`å–å€¼ï¼Œç„¶åå¯¹æ¯ä¸€ä¸ªå¯èƒ½çš„å–å€¼éšæœºå–æ ·ï¼Œç„¶ååˆ©ç”¨`i2p_inference_batch`å‡½æ•°å¾—å‡ºç½®ä¿¡åº¦ä½œä¸ºç›¸ä¼¼åº¦ï¼Ÿç„¶åé€‰å–æœ€é«˜çš„æ‰€å¯¹åº”çš„`kf_stride`ä½œä¸ºæœ€ä¼˜çš„å–å€¼ã€‚


### ä½¿ç”¨åˆå§‹çš„å‡ ä¸ªæ»‘åŠ¨çª—å£åˆ›å»ºåˆå§‹çš„å…¨å±€scene&åˆå§‹åŒ–buffer set 
å› ä¸º**SLAM3R**åˆå§‹åŒ–æ—¶çš„[ç‰¹æ®Šæ€§](http://localhost:4321/blog/slam3r/slam3r):
> å¯¹äºç¬¬ä¸€ä¸ªå¸§è¿™ç§ç‰¹æ®Šæƒ…å†µï¼Œæˆ‘ä»¬é‡‡ç”¨äº†é‡å¤è¿è¡Œå¤šæ¬¡I2Pè·å–è¶³å¤Ÿå¤šæ•°é‡çš„åˆå§‹å¸§ä½œä¸ºç¼“å†²é›†

åœ¨åŸæœ¬çš„offlineæ ¼å¼çš„`recon.py`ä¸­ï¼Œè¿™ç§åšæ³•ä»¥è¿™ç§æ ·å¼å‘ˆç°ï¼š
```python
initial_pcds, initial_confs, init_ref_id = initialize_scene(input_views[:initial_winsize*kf_stride:kf_stride], 
                                                i2p_model, 
                                                winsize=initial_winsize,
                                                return_ref_id=True) # 5*(1,224,224,3)

# start reconstrution of the whole scene
init_num = len(initial_pcds)
per_frame_res = dict(i2p_pcds=[], i2p_confs=[], l2w_pcds=[], l2w_confs=[])
for key in per_frame_res:
    per_frame_res[key] = [None for _ in range(num_views)]

registered_confs_mean = [_ for _ in range(num_views)]

# set up the world coordinates with the initial window
for i in range(init_num):
    per_frame_res['l2w_confs'][i*kf_stride] = initial_confs[i][0].to(args.device)  # 224,224
    registered_confs_mean[i*kf_stride] = per_frame_res['l2w_confs'][i*kf_stride].mean().cpu()

# initialize the buffering set with the initial window
assert args.buffer_size <= 0 or args.buffer_size >= init_num 
buffering_set_ids = [i*kf_stride for i in range(init_num)]

# set up the world coordinates with frames in the initial window
for i in range(init_num):
    input_views[i*kf_stride]['pts3d_world'] = initial_pcds[i]
    
initial_valid_masks = [conf > conf_thres_i2p for conf in initial_confs] # 1,224,224
normed_pts = normalize_views([view['pts3d_world'] for view in input_views[:init_num*kf_stride:kf_stride]],
                                            initial_valid_masks)
for i in range(init_num):
    input_views[i*kf_stride]['pts3d_world'] = normed_pts[i]
    # filter out points with low confidence
    input_views[i*kf_stride]['pts3d_world'][~initial_valid_masks[i]] = 0       
    per_frame_res['l2w_pcds'][i*kf_stride] = normed_pts[i]  # 224,224,3
```
å…¶ä¸­ï¼Œ
```python
initial_pcds, initial_confs, init_ref_id = initialize_scene(input_views[:initial_winsize*kf_stride:kf_stride], 
                                                   i2p_model, 
                                                   winsize=initial_winsize,
                                                   return_ref_id=True) # 5*(1,224,224,3)
```
è¿™ä¸€è¡Œæ˜¯å¯¹åˆå§‹åŒ–çš„å‡ ä¸ª`view_token`è¿›è¡Œåœºæ™¯é‡å»ºï¼Œå¹¶é€‰å‡ºä¸€å¼€å§‹çš„`init_ref_id`

ç„¶åä¹‹åå°±æ˜¯æŠŠæ‰€æœ‰åˆå§‹åŒ–çš„å¸§æ”¾åˆ°`buffer_set`é‡Œï¼Œç„¶åè¿›è¡Œä¸€äº›å½’ä¸€åŒ–å¤„ç†ã€‚

### å¯¹åŸå§‹çš„viewå†ç»§ç»­è¿›è¡Œi2pé‡å»ºç‚¹å›¾
è¿™é‡Œæˆ‘ä»¬é‡æ–°éå†æ‰€æœ‰å›¾åƒï¼Œå¯¹åº”è®ºæ–‡é‡Œé¢é€šè¿‡`I2P`çš„`decoder`é‡å»ºæ‰€æœ‰`view`çš„ç‚¹å›¾ã€‚æ­¤å¤–ï¼Œæ³¨æ„`initial window`çš„å…³é”®å¸§å›¾ç‰‡åŸºæœ¬ä¸Šå·²ç»åœ¨ä¸Šé¢çš„åˆå§‹åŒ–ä¸­è¢«åˆ›å»ºå‡ºäº†ç‚¹å›¾ï¼Œå› æ­¤æˆ‘ä»¬é€‰æ‹©ç•¥è¿‡ä»–ä»¬ï¼Œåªå¯¹æ²¡æœ‰è¢«åˆ›å»ºç‚¹å›¾çš„å¸§è¿›è¡Œ`I2P`å¤„ç†
ä»¥å¾—åˆ°ç‚¹å›¾ï¼Œç„¶åå°±é‡‡ç”¨è®ºæ–‡ä¸­çš„è¾“å…¥çª—å£å¤šä¸ªå¸§ï¼Œé‡å»ºæ¯ä¸ªå¸§çš„ç‚¹äº‘ä½œä¸º`L2W model`çš„è¾“å…¥ã€‚

```python
for view_id in tqdm(range(num_views), desc="I2P resonstruction"):
    # skip the views in the initial window
    if view_id in buffering_set_ids:
        # trick to mark the keyframe in the initial window
        if view_id // kf_stride == init_ref_id:
            per_frame_res['i2p_pcds'][view_id] = per_frame_res['l2w_pcds'][view_id].cpu()
        else:
            per_frame_res['i2p_pcds'][view_id] = torch.zeros_like(per_frame_res['l2w_pcds'][view_id], device="cpu")
        per_frame_res['i2p_confs'][view_id] = per_frame_res['l2w_confs'][view_id].cpu()
        continue
    # construct the local window 
    sel_ids = [view_id]
    for i in range(1,win_r+1):
        if view_id-i*adj_distance >= 0:
            sel_ids.append(view_id-i*adj_distance)
        if view_id+i*adj_distance < num_views:
            sel_ids.append(view_id+i*adj_distance)
    local_views = [input_views[id] for id in sel_ids]
    ref_id = 0 
    # recover points in the local window, and save the keyframe points and confs
    output = i2p_inference_batch([local_views], i2p_model, ref_id=ref_id, 
                                tocpu=False, unsqueeze=False)['preds']
    #save results of the i2p model
    per_frame_res['i2p_pcds'][view_id] = output[ref_id]['pts3d'].cpu() # 1,224,224,3
    per_frame_res['i2p_confs'][view_id] = output[ref_id]['conf'][0].cpu() # 224,224

    # construct the input for L2W model        
    input_views[view_id]['pts3d_cam'] = output[ref_id]['pts3d'] # 1,224,224,3
    valid_mask = output[ref_id]['conf'] > conf_thres_i2p # 1,224,224
    input_views[view_id]['pts3d_cam'] = normalize_views([input_views[view_id]['pts3d_cam']],
                                                [valid_mask])[0]
    input_views[view_id]['pts3d_cam'][~valid_mask] = 0 
```

### å¯¹åˆå§‹çª—å£éå…³é”®å¸§è¿›è¡Œæ³¨å†Œ
æ˜¾ç„¶æˆ‘ä»¬åœ¨ä¹‹å‰çš„åˆå§‹åŒ–åœºæ™¯ä¸­åªæ³¨å†Œäº†å…³é”®å¸§ï¼Œå› æ­¤æˆ‘ä»¬ç°åœ¨å¼€å§‹å¯¹éå…³é”®å¸§è¿›è¡Œæ³¨å†Œï¼š
```python
# Special treatment: register the frames within the range of initial window with L2W model
# TODO: batchify
if kf_stride > 1:
    max_conf_mean = -1
    for view_id in tqdm(range((init_num-1)*kf_stride), desc="pre-registering"):  
        if view_id % kf_stride == 0:
            continue
        # construct the input for L2W model
        l2w_input_views = [input_views[view_id]] + [input_views[id] for id in buffering_set_ids]
        # (for defination of ref_ids, see the doc of l2w_model)
        output = l2w_inference(l2w_input_views, l2w_model, 
                                ref_ids=list(range(1,len(l2w_input_views))), 
                                device=args.device,
                                normalize=args.norm_input)
        
        # process the output of L2W model
        input_views[view_id]['pts3d_world'] = output[0]['pts3d_in_other_view'] # 1,224,224,3
        conf_map = output[0]['conf'] # 1,224,224
        per_frame_res['l2w_confs'][view_id] = conf_map[0] # 224,224
        registered_confs_mean[view_id] = conf_map.mean().cpu()
        per_frame_res['l2w_pcds'][view_id] = input_views[view_id]['pts3d_world']
        
        if registered_confs_mean[view_id] > max_conf_mean:
            max_conf_mean = registered_confs_mean[view_id]
    print(f'finish aligning {(init_num-1)*kf_stride} head frames, with a max mean confidence of {max_conf_mean:.2f}')
```
è¿™é‡Œæ­£å¦‚æ³¨é‡Šæ‰€è¯´ï¼Œæ˜¯ä¸€ä¸ª**Special treatment**ã€‚ä¹Ÿæ˜¯ä¸€ä¸ªç‰¹æ®Šæƒ…å†µå¤„ç†ã€‚
#### ç¼©æ”¾confs
æˆ‘ä»¬å‘ç°ï¼Œæˆ‘ä»¬åªç”¨`l2w`ç½‘ç»œå¯¹éå…³é”®å¸§è¿›è¡Œäº†ç½®ä¿¡åº¦é¢„æµ‹ï¼Œå…³é”®å¸§çš„ç½®ä¿¡åº¦æ˜¯ç”±ä¹‹å‰çš„`i2p`ç½‘ç»œè¿›è¡Œé¢„æµ‹çš„ï¼Œä½œè€…åœ¨è¿™é‡Œä¸ºäº†æ§åˆ¶è®¡ç®—æˆæœ¬ï¼Œé€‰æ‹©ç›´æ¥å°†åè€…ä¹˜ä¸Šä¸€ä¸ªå¸¸æ•°å› å­è¿›è¡Œç¼©æ”¾ï¼Œå¤§è‡´åæ˜ å‡ºäº†åœºæ™¯çš„ç½®ä¿¡åº¦åˆ†æ•°ï¼š
```python
# A problem is that the registered_confs_mean of the initial window is generated by I2P model,
# while the registered_confs_mean of the frames within the initial window is generated by L2W model,
# so there exists a gap. Here we try to align it.
max_initial_conf_mean = -1
for i in range(init_num):
    if registered_confs_mean[i*kf_stride] > max_initial_conf_mean:
        max_initial_conf_mean = registered_confs_mean[i*kf_stride]
factor = max_conf_mean/max_initial_conf_mean
# print(f'align register confidence with a factor {factor}')
for i in range(init_num):
    per_frame_res['l2w_confs'][i*kf_stride] *= factor
    registered_confs_mean[i*kf_stride] = per_frame_res['l2w_confs'][i*kf_stride].mean().cpu()
```
### å¯¹å‰©ä¸‹çš„viewsè¿›è¡Œæ³¨å†Œ
OKï¼Œç»è¿‡äº†ä»¥ä¸Šçš„å¯¹äºåˆå§‹å¸§çš„ç‰¹æ®Šå¤„ç†ï¼Œæˆ‘ä»¬ç»ˆäºè¸å…¥äº†æ­£é€”ï¼šåœ¨è¿‡ç¨‹ä¸­å¯¹æ¯ä¸ªå¸§è¿›è¡Œå®æ—¶å¤„ç†

#### ä»buffer seté‡Œé€‰æ‹©æœ€ç›¸è¿‘çš„sel_numä¸ªå¸§ï¼š
```python
# select sccene frames in the buffering set to work as a global reference
cand_ref_ids = buffering_set_ids
ref_views, sel_pool_ids = scene_frame_retrieve(
    [input_views[i] for i in cand_ref_ids], 
    input_views[ni:ni+num_register:2], 
    i2p_model, sel_num=num_scene_frame, 
    # cand_recon_confs=[per_frame_res['l2w_confs'][i] for i in cand_ref_ids],
    depth=2)
```
è¿™é‡Œæ­£å¦‚è®ºæ–‡ä¸­æ‰€è¿°ï¼Œé‡‡ç”¨äº†`i2p_model`çš„å‰2ä¸ª**decoder**è¿›è¡Œç›¸ä¼¼è¯„åˆ†ã€‚

#### å°†é€‰å–çš„æœ€ç›¸è¿‘çš„å‡ ä¸ªå¸§ä½œä¸ºå‚è€ƒåˆå¹¶å½“å‰å¸§è¿›è¡Œl2wé‡å»º
æ˜¾è€Œæ˜“è§ï¼Œè¨€ä»¥æ¦‚ä¹‹ï¼š
```python
# register the source frames in the local coordinates to the world coordinates with L2W model
l2w_input_views = ref_views + input_views[ni:max_id+1]
input_view_num = len(ref_views) + max_id - ni + 1
assert input_view_num == len(l2w_input_views)

output = l2w_inference(l2w_input_views, l2w_model, 
                        ref_ids=list(range(len(ref_views))), 
                        device=args.device,
                        normalize=args.norm_input)

# process the output of L2W model
src_ids_local = [id+len(ref_views) for id in range(max_id-ni+1)]  # the ids of src views in the local window
src_ids_global = [id for id in range(ni, max_id+1)]    #the ids of src views in the whole dataset
succ_num = 0
for id in range(len(src_ids_global)):
    output_id = src_ids_local[id] # the id of the output in the output list
    view_id = src_ids_global[id]    # the id of the view in all views
    conf_map = output[output_id]['conf'] # 1,224,224
    input_views[view_id]['pts3d_world'] = output[output_id]['pts3d_in_other_view'] # 1,224,224,3
    per_frame_res['l2w_confs'][view_id] = conf_map[0]
    registered_confs_mean[view_id] = conf_map[0].mean().cpu()
    per_frame_res['l2w_pcds'][view_id] = input_views[view_id]['pts3d_world']
    succ_num += 1
```
import { Aside } from 'astro-pure/user'

<Aside type="tip">
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œå…¶å®è¿˜æ˜¯æœ‰æ”¹è¿›ç©ºé—´çš„ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®`l2w_model`çš„`output`å¯¹å‚è€ƒå¸§è¿›è¡Œå¾®è°ƒã€‚
</Aside>

#### é€šè¿‡ä¸€äº›æ‰‹æ®µæ›´æ–°buffer set
`buffer_set`çš„é€‰å–æ–¹æ³•å·®ä¸å¤šå°±å’Œè®ºæ–‡é‡Œé¢è®²çš„ä¸€æ ·ï¼ŒåŸºæœ¬ä¸Šå°±æ˜¯éšæœºé€‰å–äº†ã€‚
```python
# update the buffering set
if next_register_id - milestone >= update_buffer_intv:  
    while(next_register_id - milestone >= kf_stride):
        candi_frame_id += 1
        full_flag = max_buffer_size > 0 and len(buffering_set_ids) >= max_buffer_size
        insert_flag = (not full_flag) or ((strategy == 'fifo') or 
                                            (strategy == 'reservoir' and np.random.rand() < max_buffer_size/candi_frame_id))
        if not insert_flag: 
            milestone += kf_stride
            continue
        # Use offest to ensure the selected view is not too close to the last selected view
        # If the last selected view is 0, 
        # the next selected view should be at least kf_stride*3//4 frames away
        start_ids_offset = max(0, buffering_set_ids[-1]+kf_stride*3//4 - milestone)
            
        # get the mean confidence of the candidate views
        mean_cand_recon_confs = torch.stack([registered_confs_mean[i]
                                    for i in range(milestone+start_ids_offset, milestone+kf_stride)])
        mean_cand_local_confs = torch.stack([local_confs_mean[i]
                                    for i in range(milestone+start_ids_offset, milestone+kf_stride)])
        # normalize the confidence to [0,1], to avoid overconfidence
        mean_cand_recon_confs = (mean_cand_recon_confs - 1)/mean_cand_recon_confs # transform to sigmoid
        mean_cand_local_confs = (mean_cand_local_confs - 1)/mean_cand_local_confs
        # the final confidence is the product of the two kinds of confidences
        mean_cand_confs = mean_cand_recon_confs*mean_cand_local_confs
        
        most_conf_id = mean_cand_confs.argmax().item()
        most_conf_id += start_ids_offset
        id_to_buffer = milestone + most_conf_id
        buffering_set_ids.append(id_to_buffer)
        # print(f"add ref view {id_to_buffer}")                
        # since we have inserted a new frame, overflow must happen when full_flag is True
        if full_flag:
            if strategy == 'reservoir':
                buffering_set_ids.pop(np.random.randint(max_buffer_size))
            elif strategy == 'fifo':
                buffering_set_ids.pop(0)
        # print(next_register_id, buffering_set_ids)
        milestone += kf_stride
# transfer the data to cpu if it is not in the buffering set, to save gpu memory
for i in range(next_register_id):
    to_device(input_views[i], device=args.device if i in buffering_set_ids else 'cpu')
```
### ä¿å­˜ç¯èŠ‚
å½“æˆ‘ä»¬å¤„ç†å®Œæ‰€æœ‰å¸§åï¼Œæˆ‘ä»¬ä¼šä¿å­˜æˆ‘ä»¬çš„æ‰€æœ‰å¸§çš„ç‚¹äº‘ï¼ŒæŠŠè¿™äº›æ‰€æœ‰å¸§çš„ç‚¹äº‘åˆåˆ°ä¸€èµ·è¿›è¡Œé‡å»ºï¼Œå¾—å‡ºæœ€åçš„åœºæ™¯ç‚¹äº‘ã€‚

### review 
æ˜¾è€Œæ˜“è§ï¼ŒåŸ`recon.py`ä¸­çš„è¿™ä¸ª`pipeline`æ˜¯ä¸€ä¸ªå®Œå…¨çš„**offline**å¤„ç†æ–¹æ³•ï¼Œå› æ­¤ï¼Œæˆ‘ç¼–å†™äº†ä¸€ä¸ªçœŸæ­£çš„ï¼ˆï¼Ÿ**online**ç‰ˆæœ¬çš„æ–¹æ³•ï¼Œå¤„ç†é€»è¾‘å¦‚ä¸‹æ‰€ç¤ºï¼š

## online å‡½æ•°çš„å¤„ç†é€»è¾‘
æ—¢ç„¶æ˜¯è¦onlineï¼Œæˆ‘ä»¬æ˜¾ç„¶ç¬¬ä¸€ä»¶è¦åšçš„äº‹æƒ…å°±æ˜¯å†™ä¸‹ï¼š
```python
for i in range(len(data_views)):
```
ä¹‹åæˆ‘ä»¬åœ¨è¿›è¡Œä¸€ç³»åˆ—å¤„ç†ï¼š

### é¢„å¤„ç† & å¾—åˆ°å½“å‰viewçš„token

æ˜¾ç„¶ï¼Œé€šè¿‡å¯¹åŸå…ˆ**offline**ç‰ˆæœ¬çš„å‡½æ•°åˆ†æï¼Œè¿™ä¸ªè¿‡ç¨‹æ²¡æœ‰åˆå§‹åŒ–çš„å›°æ‰°ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¤§èƒ†å¯¹æ‰€æœ‰éå†åˆ°çš„viewéƒ½è¿›è¡Œè¿™ä¸€æ­¥ï¼š
```python
# Pre-save the RGB images along with their corresponding masks
# in preparation for visualization at last.

if data_views[i]['img'].shape[0] == 1:
    data_views[i]['img'] = data_views[i]['img'][0]
rgb_imgs.append(transform_img(dict(img=data_views[i]['img'][None]))[...,::-1])

if is_have_mask_rgb:
    valid_masks.append(data_views[i]['valid_mask'])

# process now image for extracting its img token with encoder
data_views[i]['img'] = torch.tensor(data_views[i]['img'][None])
data_views[i]['true_shape'] = torch.tensor(data_views[i]['true_shape'][None])
for key in ['valid_mask', 'pts3d_cam', 'pts3d']:
    if key in data_views[i]:
        del data_views[key]
to_device(data_views[i], device=args.device)

# pre-extract img tokens by encoder, which can be reused 
# in the following inference by both i2p and l2w models
temp_shape, temp_feat, temp_pose = get_single_img_tokens([data_views[i]], i2p_model, True)
res_shapes.append(temp_shape[0])
res_feats.append(temp_feat[0])
res_poses.append(temp_pose[0])
print(f"finish pre-extracting img token of view {i}")

input_views.append(dict(label=data_views[i]['label'],
                        img_tokens=temp_feat[0],
                        true_shape=data_views[i]['true_shape'],
                        img_pos=temp_pose[0]))
for key in per_frame_res:
    per_frame_res[key].append(None)
registered_confs_mean.append(i)
```
è¿™é‡Œæˆ‘ä½¿ç”¨äº†ä¸€ä¸ª`get_single_img_tokens`å‡½æ•°ï¼Œä¸ä¹‹å‰çš„`get_img_tokens`å‡½æ•°ç›¸æ¯”ï¼Œè¯¥å‡½æ•°é™¤äº†ä¸èƒ½batchåŒ–(onlineçš„é™åˆ¶)ä¹‹å¤–ï¼Œæ•ˆæœè¾“å‡ºåˆ«æ— äºŒè‡´ã€‚


### ç§¯ç´¯å¸§ä»¥ç”¨äºåœºæ™¯åˆå§‹åŒ–
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“å¸§åºæ•°å°äºåˆå§‹åŒ–æ‰€éœ€è¦çš„å¸§æ•°æ—¶ï¼Œæˆ‘ä»¬åç»­çš„ç¨‹åºå‡æ— æ³•è¿›è¡Œï¼Œå› æ­¤åœ¨æˆ‘çš„ä»£ç ä¸­ï¼Œæˆ‘é€‰æ‹©ç›´æ¥è·³è¿‡ï¼Œå…ˆè“„åŠ¿å¾…å‘ğŸ¤£

ä¸€æ—¦ç§¯ç´¯åˆ°åˆå§‹åŒ–åœºæ™¯æ‰€éœ€å¸§åï¼Œå‡½æ•°ä¼šé‡‡ç”¨ä¸€ç³»åˆ—æ“ä½œåˆå§‹åŒ–åœºæ™¯ä»¥åŠåˆå§‹åŒ–buffer setï¼Œå¯¹åˆå§‹åŒ–åçš„å„å¸§ç‚¹äº‘è¿›è¡Œå½’ä¸€åŒ–å¤„ç†ï¼š

```python
# accumulate the initial window frames
if i < (initial_winsize - 1)*kf_stride and i % kf_stride == 0:
    continue
elif i == (initial_winsize - 1)*kf_stride:
    initial_pcds, initial_confs, init_ref_id = initialize_scene(input_views[:initial_winsize*kf_stride:kf_stride],
                                                                i2p_model,
                                                                winsize=initial_winsize,
                                                                return_ref_id=True)
    # set up the world coordinates with the initial window
    init_num = len(initial_pcds)
    for j in range(init_num):
        per_frame_res['l2w_confs'][j * kf_stride] = initial_confs[j][0].to(args.device)
        registered_confs_mean[j * kf_stride] = per_frame_res['l2w_confs'][j * kf_stride].mean().cpu()
    # initialize the buffering set with the initial window
    assert args.buffer_size <= 0 or args.buffer_size >= init_num 
    buffering_set_ids = [j*kf_stride for j in range(init_num)]
    # set ip the woeld coordinates with frames in the initial window
    for j in range(init_num):
        input_views[j*kf_stride]['pts3d_world'] = initial_pcds[j]
    initial_valid_masks = [conf > conf_thres_i2p for conf in initial_confs]
    normed_pts = normalize_views([view['pts3d_world'] for view in input_views[:init_num*kf_stride:kf_stride]],
                                                initial_valid_masks)
    for j in range(init_num):
        input_views[j*kf_stride]['pts3d_world'] = normed_pts[j]
        # filter out points with low confidence
        input_views[j*kf_stride]['pts3d_world'][~initial_valid_masks[j]] = 0
        per_frame_res['l2w_pcds'][j*kf_stride] = normed_pts[j]

elif i < (initial_winsize - 1) * kf_stride:
    continue
```
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œä¸€æ—¦ç§¯ç´¯åˆ°è¶³å¤Ÿå¤šçš„åˆå§‹å¸§ï¼Œæˆ‘ä»¬å°±ä¸ä¼šè¿›è¡Œcontinueå¤„ç†äº†ï¼Œç„¶åç›´æ¥è¿›è¡Œä¸‹ä¸€éƒ¨åˆ†ã€‚

### å¯¹ä¹‹å‰ç§¯ç´¯çš„viewè¿›è¡Œi2pé‡å»ºç‚¹å›¾ï¼ˆåŒ…å«æ­£åœ¨å¤„ç†çš„å¸§ï¼‰ & æ³¨å†Œåˆå§‹çª—å£éå…³é”®å¸§
è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨ç±»ä¼¼äºä¹‹å‰**offline**çš„é¡ºåºï¼Œåªä¸è¿‡æŠŠå¤–åœ¨çš„è¡¨ç°å½¢å¼ä½œå‡ºäº†æ”¹å˜ï¼Œå®é™…ä¸Šå†…åœ¨çš„é¡ºåºé€»è¾‘åŸºæœ¬ä¸å˜ï¼š
```python
# first recover the accumulate views
if i == (initial_winsize - 1) * kf_stride:
    for view_id in range(i + 1):
        # skip the views in the initial window
        if view_id in buffering_set_ids:
            # trick to mark the keyframe in the initial window
            if view_id // kf_stride == init_ref_id:
                per_frame_res['i2p_pcds'][view_id] = per_frame_res['l2w_pcds'][view_id].cpu()
            else:
                per_frame_res['i2p_pcds'][view_id] = torch.zeros_like(per_frame_res['l2w_pcds'][view_id], device="cpu")
            per_frame_res['i2p_confs'][view_id] = per_frame_res['l2w_confs'][view_id].cpu()
            print(f"finish revocer pcd of frame {view_id} in their local coordinates(in buffer set), with a mean confidence of {per_frame_res['i2p_confs'][view_id].mean():.2f} up to now.")
            continue
        # construct the local window with the initial views
        sel_ids = [view_id]
        for j in range(1, win_r + 1):
            if view_id - j * adj_distance >= 0:
                sel_ids.append(view_id - j * adj_distance)
            if view_id + j * adj_distance < i:
                sel_ids.append(view_id + j * adj_distance)
        local_views = [input_views[id] for id in sel_ids]
        ref_id = 0

        # recover poionts in the initial window, and save the keyframe points and confs
        output = i2p_inference_batch([local_views], i2p_model, ref_id=ref_id,
                                        tocpu=False, unsqueeze=False)['preds']
        # save results of the i2p model for the initial window
        per_frame_res['i2p_pcds'][view_id] = output[ref_id]['pts3d'].cpu()
        per_frame_res['i2p_confs'][view_id] = output[ref_id]['conf'][0].cpu()

        # construct the input for L2W model
        input_views[view_id]['pts3d_cam'] = output[ref_id]['pts3d']
        valid_mask = output[ref_id]['conf'] > conf_thres_i2p
        input_views[view_id]['pts3d_cam'] = normalize_views([input_views[view_id]['pts3d_cam']],
                                                                [valid_mask])[0]
        input_views[view_id]['pts3d_cam'][~valid_mask] = 0

        local_confs_mean_up2now = [conf.mean() for conf in per_frame_res['i2p_confs'] if conf is not None]
        print(f"finish revocer pcd of frame {view_id} in their local coordinates, with a mean confidence of {torch.stack(local_confs_mean_up2now).mean():.2f} up to now.")

    # Special treatment: register the frames within the range of initial window with L2W model
    if kf_stride > 1:
        max_conf_mean = -1
        for view_id in tqdm(range((init_num - 1) * kf_stride), desc="pre-registering"):
            if view_id % kf_stride == 0:
                continue
            # construct the input for L2W model

            l2w_input_views = [input_views[view_id]] + [input_views[id] for id in buffering_set_ids]
            # (for defination of ref_ids, seee the doc of l2w_model)
            output = l2w_inference(l2w_input_views, l2w_model,
                                    ref_ids=list(range(1,len(l2w_input_views))),
                                    device=args.device,
                                    normalize=args.norm_input)
            # process the output of L2W model
            input_views[view_id]['pts3d_world'] = output[0]['pts3d_in_other_view'] # 1,224,224,3
            conf_map = output[0]['conf'] # 1,224,224
            per_frame_res['l2w_confs'][view_id] = conf_map[0] # 224,224
            registered_confs_mean[view_id] = conf_map.mean().cpu()
            per_frame_res['l2w_pcds'][view_id] = input_views[view_id]['pts3d_world']
            
            if registered_confs_mean[view_id] > max_conf_mean:
                max_conf_mean = registered_confs_mean[view_id]
        print(f'finish aligning {(init_num)*kf_stride} head frames, with a max mean confidence of {max_conf_mean:.2f}')
        # A problem is that the registered_confs_mean of the initial window is generated by I2P model,
        # while the registered_confs_mean of the frames within the initial window is generated by L2W model,
        # so there exists a gap. Here we try to align it.
        max_initial_conf_mean = -1
        for i in range(init_num):
            if registered_confs_mean[i*kf_stride] > max_initial_conf_mean:
                max_initial_conf_mean = registered_confs_mean[i*kf_stride]
        factor = max_conf_mean/max_initial_conf_mean
        # print(f'align register confidence with a factor {factor}')
        for i in range(init_num):
            per_frame_res['l2w_confs'][i*kf_stride] *= factor
            registered_confs_mean[i*kf_stride] = per_frame_res['l2w_confs'][i*kf_stride].mean().cpu()
    # register the rest frames with L2W model
    next_register_id = (init_num - 1) * kf_stride + 1
    milestone = init_num * kf_stride + 1
    update_buffer_intv = kf_stride*args.update_buffer_intv   # update the buffering set every update_buffer_intv frames
    max_buffer_size = args.buffer_size
    strategy = args.buffer_strategy
    candi_frame_id = len(buffering_set_ids) # used for the reservoir sampling strategy
    continue
```
ç„¶ååœ¨å¤„ç†å®Œè¿™ä¹ˆä¸€å †ä¹‹åæˆ‘ä»¬ç›´æ¥`continue`åˆ°ä¸‹ä¸€ä¸ªå¾ªç¯ã€‚

### å¤„ç†æ–°å›¾ç‰‡
åœ¨ä¸‹ä¸€ä¸ªå¾ªç¯ä¸­ï¼Œæˆ‘ä»¬æ‹¿åˆ°äº†æ–°å›¾ç‰‡ï¼Œæ­¤æ—¶æˆ‘ä»¬ä¹Ÿåœ¨æˆ‘ä»¬çš„**online**å‡½æ•°ä¸­è¸ä¸Šäº†æ­£é€”ï¼Œå¯ä»¥å¯¹æ¯ä¸€ä¸ªå¸§è¿›è¡Œå®æ—¶å¤„ç†äº†ã€‚

è¿™é‡Œï¼Œæˆ‘ä»¬çš„å¤„ç†é€»è¾‘ä¸ç¬¬ä¸€ç§æ–¹æ³•ç±»ä¼¼ï¼Œä¸åŒçš„ä¸€ç‚¹æ˜¯æˆ‘æ˜¯ä¸€å¸§ä¸€å¸§åœ°å»å¤„ç†ã€‚

### ä¿å­˜ç¯èŠ‚
ä¸ä¸Šä¸€ä¸ªæ–¹æ³•ç•¥å¾®ä¸åŒï¼Œæˆ‘æä¾›äº†å‚æ•°é€‰é¡¹é€‰æ‹©æ˜¯å¦åœ¨çº¿ä¿å­˜/é€å‡ å¸§ä¿å­˜ï¼Œå› æ­¤æˆ‘é‡å†™äº†ä¸€ä¸ªå¢é‡å¼ä¿å­˜çš„ç±»ï¼š
```python
class IncrementalReconstructor:
    """
    A class used for reconstruting the pts incrementally
    """
    def __init__(self):
        self.res_pcds = None
        self.res_rgbs = None
        self.res_confs = None
        self.res_valid_masks = None
        self.is_initialized = False

    def add_frame(self, view: dict, img: np.ndarray, conf: np.ndarray = None, valid_mask: np.ndarray = None):
        """
        Incrementally add a new frame of view data.

        Args:
            view (dict): a dictionary for a new view
            img (np.ndarray): rgb_img
            conf (np.ndarray, optional): 
            valid_mask (np.ndarray, optional): 
        """
        try:
            new_pcd = to_numpy(view['pts3d_world']).reshape(-1, 3)
            new_rgb = to_numpy(img).reshape(-1, 3)
        except KeyError:
            print(f"Warning: 'pts3d_world' not found in the new view. Frame skipped.")
            return
        if not self.is_initialized:
            self.res_pcds = new_pcd
            self.res_rgbs = new_rgb
            if conf is not None:
                self.res_confs = to_numpy(conf).reshape(-1)
            if valid_mask is not None:
                self.res_valid_masks = to_numpy(valid_mask).reshape(-1)
            self.is_initialized = True
        else:
            self.res_pcds = np.concatenate([self.res_pcds, new_pcd], axis=0)
            self.res_rgbs = np.concatenate([self.res_rgbs, new_rgb], axis=0)
            if conf is not None:
                new_conf = to_numpy(conf).reshape(-1)
                self.res_confs = np.concatenate([self.res_confs, new_conf], axis=0)
            if valid_mask is not None:
                new_mask = to_numpy(valid_mask).reshape(-1)
                self.res_valid_masks = np.concatenate([self.res_valid_masks, new_mask], axis=0)

    def save_snapshot(self, snapshot_id: int, save_dir: str, num_points_save: int = 200000, conf_thres_res: float = 3.0):
        """
        Just save
        """
        if not self.is_initialized:
            print("Warning: Reconstructor not initialized. Nothing to save.")
            return
        save_name = f"recon_snapshot_{snapshot_id:05d}.ply"
        pts_count = len(self.res_pcds)
        final_valid_mask = np.ones(pts_count, dtype=bool)

        if self.res_valid_masks is not None:
            final_valid_mask &= self.res_valid_masks
        
        if self.res_confs is not None:
            conf_masks = self.res_confs > conf_thres_res
            final_valid_mask &= conf_masks

        valid_ids = np.where(final_valid_mask)[0]
        
        if len(valid_ids) == 0:
            print(f"Warning for snapshot {snapshot_id}: No valid points left after filtering.")
            return
            
        print(f'Snapshot {snapshot_id}: Ratio of points filtered out: {(1. - len(valid_ids) / pts_count) * 100:.2f}%')
        n_samples = min(num_points_save, len(valid_ids))
        print(f"Snapshot {snapshot_id}: Resampling {n_samples} points from {len(valid_ids)} valid points.")
        sampled_idx = np.random.choice(valid_ids, n_samples, replace=False)
        sampled_pts = self.res_pcds[sampled_idx]
        sampled_rgbs = self.res_rgbs[sampled_idx]
        save_path = join(save_dir, save_name)
        print(f"Saving reconstruction snapshot to {save_path}")
        save_ply(points=sampled_pts, save_path=save_path, colors=sampled_rgbs)
```

åœ¨æ¯ä¸€ä¸ªå¾ªç¯æœ€ååŠ ä»¥è°ƒç”¨ï¼š
```python
reconstructor.add_frame(
            view=input_views[i],
            img=rgb_imgs[i],
            conf=per_frame_res['l2w_confs'][i],
            valid_mask=valid_masks
        )
        if args.save_online:
            if (i + 1) % args.save_frequency == 0:
                reconstructor.save_snapshot(
                    snapshot_id=i + 1,
                    save_dir=save_dir,
                    num_points_save=num_points_save,
                    conf_thres_res=conf_thres_l2w
                )
```
OKï¼Œåˆ°æ­¤ä¸ºæ­¢æˆ‘å°±å†™å®Œäº†åŸæœ¬çš„å¤„ç†é€»è¾‘çš„è§£é‡Šå’Œæ–°å†™çš„**onlinee*å¤„ç†é€»è¾‘ä»‹ç»ï¼Œå…¶å®è¦è¯´ä¸è¯´ï¼Œ**online**å¤„ç†é€»è¾‘ä¹Ÿå¹¶éå¤ªè¿‡å¤æ‚ï¼Œä½†æ˜¯å¥ˆä½•æˆ‘è¿™å‡ å¤©å› ä¸ºå­¦è½¦è€½è¯¯äº†å¤ªå¤šæ—¶é—´ä¹Ÿæ²¡åšä»€ä¹ˆä¸œè¥¿ï¼ˆx

<Spoiler>åˆæ°´äº†ä¸€ç¯‡blogğŸ˜‹</Spoiler>